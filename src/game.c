/* game.c generated by valac 0.34.7, the Vala compiler
 * generated from game.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <SDL.h>
#include <stdlib.h>
#include <string.h>
#include <emscripten.h>

typedef struct _Game Game;

#define ENTITAS_TYPE_ENTITY (entitas_entity_get_type ())

#define ENTITAS_TYPE_BACKGROUND (entitas_background_get_type ())
typedef struct _entitasBackground entitasBackground;

#define ENTITAS_TYPE_BOUNDS (entitas_bounds_get_type ())
typedef struct _entitasBounds entitasBounds;

#define ENTITAS_TYPE_BULLET (entitas_bullet_get_type ())
typedef struct _entitasBullet entitasBullet;

#define ENTITAS_TYPE_ENEMY1 (entitas_enemy1_get_type ())
typedef struct _entitasEnemy1 entitasEnemy1;

#define ENTITAS_TYPE_ENEMY2 (entitas_enemy2_get_type ())
typedef struct _entitasEnemy2 entitasEnemy2;

#define ENTITAS_TYPE_ENEMY3 (entitas_enemy3_get_type ())
typedef struct _entitasEnemy3 entitasEnemy3;

#define ENTITAS_TYPE_EXPIRES (entitas_expires_get_type ())
typedef struct _entitasExpires entitasExpires;

#define ENTITAS_TYPE_HEALTH (entitas_health_get_type ())
typedef struct _entitasHealth entitasHealth;

#define ENTITAS_TYPE_HUD (entitas_hud_get_type ())
typedef struct _entitasHud entitasHud;

#define ENTITAS_TYPE_INDEX (entitas_index_get_type ())
typedef struct _entitasIndex entitasIndex;

#define ENTITAS_TYPE_LAYER (entitas_layer_get_type ())
typedef struct _entitasLayer entitasLayer;

#define ENTITAS_TYPE_POSITION (entitas_position_get_type ())
typedef struct _entitasPosition entitasPosition;

#define ENTITAS_TYPE_SCALE (entitas_scale_get_type ())
typedef struct _entitasScale entitasScale;

#define ENTITAS_TYPE_SPRITE (entitas_sprite_get_type ())
typedef struct _entitasSprite entitasSprite;

#define ENTITAS_TYPE_TEXT (entitas_text_get_type ())
typedef struct _entitasText entitasText;

#define ENTITAS_TYPE_TINT (entitas_tint_get_type ())
typedef struct _entitasTint entitasTint;

#define ENTITAS_TYPE_TWEEN (entitas_tween_get_type ())
typedef struct _entitasTween entitasTween;

#define ENTITAS_TYPE_VELOCITY (entitas_velocity_get_type ())
typedef struct _entitasVelocity entitasVelocity;
typedef struct _entitasEntity entitasEntity;
typedef struct _Factory Factory;
#define _factory_free0(var) ((var == NULL) ? NULL : (var = (factory_free (var), NULL)))
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

#define TYPE_POOL (pool_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))

struct _entitasBackground {
	gboolean active;
};

struct _entitasBounds {
	gint x;
	gint y;
	gint w;
	gint h;
};

struct _entitasBullet {
	gboolean active;
};

struct _entitasEnemy1 {
	gboolean active;
};

struct _entitasEnemy2 {
	gboolean active;
};

struct _entitasEnemy3 {
	gboolean active;
};

struct _entitasExpires {
	gdouble value;
};

struct _entitasHealth {
	gdouble current;
	gdouble maximum;
};

struct _entitasHud {
	gboolean active;
};

struct _entitasIndex {
	gint value;
};

struct _entitasLayer {
	gint value;
};

struct _entitasPosition {
	gdouble x;
	gdouble y;
};

struct _entitasScale {
	gdouble x;
	gdouble y;
};

struct _entitasSprite {
	SDL_Surface* surface;
};

struct _entitasText {
	gchar* text;
	SDL_Surface* surface;
};

struct _entitasTint {
	gint r;
	gint g;
	gint b;
	gint a;
};

struct _entitasTween {
	gdouble min;
	gdouble max;
	gdouble speed;
	gboolean repeat;
	gboolean active;
};

struct _entitasVelocity {
	gdouble x;
	gdouble y;
};

struct _entitasEntity {
	gint id;
	gchar* name;
	gint pool;
	guint64 mask;
	entitasBackground* background;
	entitasBounds* bounds;
	entitasBullet* bullet;
	entitasEnemy1* enemy1;
	entitasEnemy2* enemy2;
	entitasEnemy3* enemy3;
	entitasExpires* expires;
	entitasHealth* health;
	entitasHud* hud;
	entitasIndex* index;
	entitasLayer* layer;
	entitasPosition* position;
	entitasScale* scale;
	entitasSprite* sprite;
	entitasText* text;
	entitasTint* tint;
	entitasTween* tween;
	entitasVelocity* velocity;
};

struct _Game {
	gdouble mark1;
	gdouble mark2;
	gdouble delta;
	gdouble mouseX;
	gdouble mouseY;
	gboolean mouseDown;
	gboolean running;
	guint8 keys[256];
	SDL_Event evt;
	SDL_Surface* surface;
	entitasEntity* player;
	Factory* factory;
	GList* sprites;
	gdouble FireRate;
	gdouble timeToFire;
	gboolean shoot;
	gdouble scale;
};

typedef enum  {
	POOL_BACKGROUND,
	POOL_ENEMY1,
	POOL_ENEMY2,
	POOL_ENEMY3,
	POOL_PLAYER,
	POOL_BULLET,
	POOL_EXPLOSION,
	POOL_BANG,
	POOL_PARTICLE,
	POOL_HUD,
	POOL_Count
} Pool;

struct _Factory {
	entitasEntity pool[20];
	gint id;
	SDL_Surface** cache;
	gint cache_length1;
};



void game_free (Game* self);
GType entitas_entity_get_type (void) G_GNUC_CONST;
GType entitas_background_get_type (void) G_GNUC_CONST;
entitasBackground* entitas_background_dup (const entitasBackground* self);
void entitas_background_free (entitasBackground* self);
GType entitas_bounds_get_type (void) G_GNUC_CONST;
entitasBounds* entitas_bounds_dup (const entitasBounds* self);
void entitas_bounds_free (entitasBounds* self);
GType entitas_bullet_get_type (void) G_GNUC_CONST;
entitasBullet* entitas_bullet_dup (const entitasBullet* self);
void entitas_bullet_free (entitasBullet* self);
GType entitas_enemy1_get_type (void) G_GNUC_CONST;
entitasEnemy1* entitas_enemy1_dup (const entitasEnemy1* self);
void entitas_enemy1_free (entitasEnemy1* self);
GType entitas_enemy2_get_type (void) G_GNUC_CONST;
entitasEnemy2* entitas_enemy2_dup (const entitasEnemy2* self);
void entitas_enemy2_free (entitasEnemy2* self);
GType entitas_enemy3_get_type (void) G_GNUC_CONST;
entitasEnemy3* entitas_enemy3_dup (const entitasEnemy3* self);
void entitas_enemy3_free (entitasEnemy3* self);
GType entitas_expires_get_type (void) G_GNUC_CONST;
entitasExpires* entitas_expires_dup (const entitasExpires* self);
void entitas_expires_free (entitasExpires* self);
GType entitas_health_get_type (void) G_GNUC_CONST;
entitasHealth* entitas_health_dup (const entitasHealth* self);
void entitas_health_free (entitasHealth* self);
GType entitas_hud_get_type (void) G_GNUC_CONST;
entitasHud* entitas_hud_dup (const entitasHud* self);
void entitas_hud_free (entitasHud* self);
GType entitas_index_get_type (void) G_GNUC_CONST;
entitasIndex* entitas_index_dup (const entitasIndex* self);
void entitas_index_free (entitasIndex* self);
GType entitas_layer_get_type (void) G_GNUC_CONST;
entitasLayer* entitas_layer_dup (const entitasLayer* self);
void entitas_layer_free (entitasLayer* self);
GType entitas_position_get_type (void) G_GNUC_CONST;
entitasPosition* entitas_position_dup (const entitasPosition* self);
void entitas_position_free (entitasPosition* self);
GType entitas_scale_get_type (void) G_GNUC_CONST;
entitasScale* entitas_scale_dup (const entitasScale* self);
void entitas_scale_free (entitasScale* self);
GType entitas_sprite_get_type (void) G_GNUC_CONST;
entitasSprite* entitas_sprite_dup (const entitasSprite* self);
void entitas_sprite_free (entitasSprite* self);
GType entitas_text_get_type (void) G_GNUC_CONST;
entitasText* entitas_text_dup (const entitasText* self);
void entitas_text_free (entitasText* self);
void entitas_text_copy (const entitasText* self, entitasText* dest);
void entitas_text_destroy (entitasText* self);
GType entitas_tint_get_type (void) G_GNUC_CONST;
entitasTint* entitas_tint_dup (const entitasTint* self);
void entitas_tint_free (entitasTint* self);
GType entitas_tween_get_type (void) G_GNUC_CONST;
entitasTween* entitas_tween_dup (const entitasTween* self);
void entitas_tween_free (entitasTween* self);
GType entitas_velocity_get_type (void) G_GNUC_CONST;
entitasVelocity* entitas_velocity_dup (const entitasVelocity* self);
void entitas_velocity_free (entitasVelocity* self);
entitasEntity* entitas_entity_dup (const entitasEntity* self);
void entitas_entity_free (entitasEntity* self);
void entitas_entity_copy (const entitasEntity* self, entitasEntity* dest);
void entitas_entity_destroy (entitasEntity* self);
void factory_free (Factory* self);
static void game_instance_init (Game * self);
void game_initialize (Game* self);
Factory* factory_new (void);
entitasEntity* factory_createBackground (Factory* self, gint index, gint tile);
GType pool_get_type (void) G_GNUC_CONST;
entitasEntity* factory_createPlayer (Factory* self, gint index);
gboolean entitas_entity_isActive (entitasEntity *self);
gchar* entitas_entity_toString (entitasEntity *self);
void game_start (Game* self);
void game_processEvents (Game* self);
void game_update (Game* self);
void game_inputSystem (Game* self, gdouble delta);
void game_physicsSystem (Game* self, gdouble delta);
gboolean entitas_entity_hasVelocity (entitasEntity *self);
Game* game_new (void);


void game_initialize (Game* self) {
	Factory* _tmp0_ = NULL;
	Factory* _tmp1_ = NULL;
	Factory* _tmp2_ = NULL;
	Factory* _tmp3_ = NULL;
	entitasEntity* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = factory_new ();
	_factory_free0 (self->factory);
	self->factory = _tmp0_;
	_tmp1_ = self->factory;
	factory_createBackground (_tmp1_, (gint) POOL_BACKGROUND, 0);
	_tmp2_ = self->factory;
	factory_createBackground (_tmp2_, (gint) POOL_BACKGROUND, 1);
	_tmp3_ = self->factory;
	_tmp4_ = factory_createPlayer (_tmp3_, (gint) POOL_PLAYER);
	self->player = _tmp4_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp5_ = FALSE;
			_tmp5_ = TRUE;
			while (TRUE) {
				Factory* _tmp7_ = NULL;
				gint _tmp8_ = 0;
				gboolean _tmp9_ = FALSE;
				Factory* _tmp10_ = NULL;
				gint _tmp11_ = 0;
				gchar* _tmp12_ = NULL;
				gchar* _tmp13_ = NULL;
				if (!_tmp5_) {
					gint _tmp6_ = 0;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp5_ = FALSE;
				if (!(i <= 19)) {
					break;
				}
				_tmp7_ = self->factory;
				_tmp8_ = i;
				_tmp9_ = entitas_entity_isActive (&_tmp7_->pool[_tmp8_]);
				if (!_tmp9_) {
					continue;
				}
				_tmp10_ = self->factory;
				_tmp11_ = i;
				_tmp12_ = entitas_entity_toString (&_tmp10_->pool[_tmp11_]);
				_tmp13_ = _tmp12_;
				g_print ("%s\n", _tmp13_);
				_g_free0 (_tmp13_);
			}
		}
	}
}


void game_start (Game* self) {
	gdouble _tmp0_ = 0.0;
	g_return_if_fail (self != NULL);
	self->running = TRUE;
	_tmp0_ = emscripten_get_now ();
	self->mark1 = _tmp0_ / 1000;
}


void game_processEvents (Game* self) {
	g_return_if_fail (self != NULL);
	while (TRUE) {
		SDL_Event _tmp0_ = {0};
		gint _tmp1_ = 0;
		SDL_Event _tmp2_ = {0};
		gint _tmp3_ = 0;
		_tmp1_ = SDL_PollEvent (&_tmp0_);
		self->evt = _tmp0_;
		if (!(_tmp1_ != 0)) {
			break;
		}
		_tmp2_ = self->evt;
		_tmp3_ = _tmp2_.type;
		switch (_tmp3_) {
			case SDL_QUIT:
			{
				{
					self->running = FALSE;
				}
				break;
			}
			case SDL_KEYDOWN:
			{
				{
					SDL_Event _tmp4_ = {0};
					SDL_KeyboardEvent _tmp5_ = {0};
					SDL_keysym _tmp6_ = {0};
					int _tmp7_ = 0;
					guint8 _tmp8_ = 0U;
					_tmp4_ = self->evt;
					_tmp5_ = _tmp4_.key;
					_tmp6_ = _tmp5_.keysym;
					_tmp7_ = _tmp6_.sym;
					self->keys[_tmp7_] = (guint8) 1;
					_tmp8_ = self->keys[_tmp7_];
				}
				break;
			}
			case SDL_KEYUP:
			{
				{
					SDL_Event _tmp9_ = {0};
					SDL_KeyboardEvent _tmp10_ = {0};
					SDL_keysym _tmp11_ = {0};
					int _tmp12_ = 0;
					guint8 _tmp13_ = 0U;
					_tmp9_ = self->evt;
					_tmp10_ = _tmp9_.key;
					_tmp11_ = _tmp10_.keysym;
					_tmp12_ = _tmp11_.sym;
					self->keys[_tmp12_] = (guint8) 0;
					_tmp13_ = self->keys[_tmp12_];
				}
				break;
			}
			case SDL_MOUSEMOTION:
			{
				{
					SDL_Event _tmp14_ = {0};
					SDL_MouseMotionEvent _tmp15_ = {0};
					guint16 _tmp16_ = 0U;
					SDL_Event _tmp17_ = {0};
					SDL_MouseMotionEvent _tmp18_ = {0};
					guint16 _tmp19_ = 0U;
					_tmp14_ = self->evt;
					_tmp15_ = _tmp14_.motion;
					_tmp16_ = _tmp15_.x;
					self->mouseX = (gdouble) _tmp16_;
					_tmp17_ = self->evt;
					_tmp18_ = _tmp17_.motion;
					_tmp19_ = _tmp18_.y;
					self->mouseY = (gdouble) _tmp19_;
				}
				break;
			}
			case SDL_MOUSEBUTTONDOWN:
			{
				{
					self->mouseDown = TRUE;
				}
				break;
			}
			case SDL_MOUSEBUTTONUP:
			{
				{
					self->mouseDown = FALSE;
				}
				break;
			}
			default:
			break;
		}
	}
}


void game_update (Game* self) {
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	SDL_Surface* _tmp6_ = NULL;
	SDL_Surface* _tmp7_ = NULL;
	SDL_PixelFormat* _tmp8_ = NULL;
	guint32 _tmp9_ = 0U;
	SDL_Surface* _tmp43_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = emscripten_get_now ();
	self->mark2 = _tmp0_ / 1000;
	_tmp1_ = self->mark2;
	_tmp2_ = self->mark1;
	self->delta = _tmp1_ - _tmp2_;
	_tmp3_ = self->mark2;
	self->mark1 = _tmp3_;
	game_processEvents (self);
	_tmp4_ = self->delta;
	game_inputSystem (self, _tmp4_);
	_tmp5_ = self->delta;
	game_physicsSystem (self, _tmp5_);
	_tmp6_ = self->surface;
	_tmp7_ = self->surface;
	_tmp8_ = _tmp7_->format;
	_tmp9_ = SDL_MapRGB (_tmp8_, (guchar) 255, (guchar) 0, (guchar) 0);
	SDL_FillRect (_tmp6_, NULL, _tmp9_);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp10_ = FALSE;
			_tmp10_ = TRUE;
			while (TRUE) {
				Factory* _tmp12_ = NULL;
				Factory* _tmp13_ = NULL;
				gint _tmp14_ = 0;
				gboolean _tmp15_ = FALSE;
				Factory* _tmp16_ = NULL;
				gint _tmp17_ = 0;
				entitasEntity _tmp18_ = {0};
				entitasSprite* _tmp19_ = NULL;
				SDL_Surface* _tmp20_ = NULL;
				SDL_Surface* _tmp21_ = NULL;
				Factory* _tmp22_ = NULL;
				gint _tmp23_ = 0;
				entitasEntity _tmp24_ = {0};
				entitasBounds* _tmp25_ = NULL;
				gint _tmp26_ = 0;
				Factory* _tmp27_ = NULL;
				gint _tmp28_ = 0;
				entitasEntity _tmp29_ = {0};
				entitasBounds* _tmp30_ = NULL;
				gint _tmp31_ = 0;
				Factory* _tmp32_ = NULL;
				gint _tmp33_ = 0;
				entitasEntity _tmp34_ = {0};
				entitasBounds* _tmp35_ = NULL;
				gint _tmp36_ = 0;
				Factory* _tmp37_ = NULL;
				gint _tmp38_ = 0;
				entitasEntity _tmp39_ = {0};
				entitasBounds* _tmp40_ = NULL;
				gint _tmp41_ = 0;
				SDL_Rect _tmp42_ = {0};
				if (!_tmp10_) {
					gint _tmp11_ = 0;
					_tmp11_ = i;
					i = _tmp11_ + 1;
				}
				_tmp10_ = FALSE;
				_tmp12_ = self->factory;
				if (!(i <= (20 - 1))) {
					break;
				}
				_tmp13_ = self->factory;
				_tmp14_ = i;
				_tmp15_ = entitas_entity_isActive (&_tmp13_->pool[_tmp14_]);
				if (!_tmp15_) {
					continue;
				}
				_tmp16_ = self->factory;
				_tmp17_ = i;
				_tmp18_ = _tmp16_->pool[_tmp17_];
				_tmp19_ = _tmp18_.sprite;
				_tmp20_ = (*_tmp19_).surface;
				_tmp21_ = self->surface;
				_tmp22_ = self->factory;
				_tmp23_ = i;
				_tmp24_ = _tmp22_->pool[_tmp23_];
				_tmp25_ = _tmp24_.bounds;
				_tmp26_ = (*_tmp25_).x;
				_tmp27_ = self->factory;
				_tmp28_ = i;
				_tmp29_ = _tmp27_->pool[_tmp28_];
				_tmp30_ = _tmp29_.bounds;
				_tmp31_ = (*_tmp30_).y;
				_tmp32_ = self->factory;
				_tmp33_ = i;
				_tmp34_ = _tmp32_->pool[_tmp33_];
				_tmp35_ = _tmp34_.bounds;
				_tmp36_ = (*_tmp35_).w;
				_tmp37_ = self->factory;
				_tmp38_ = i;
				_tmp39_ = _tmp37_->pool[_tmp38_];
				_tmp40_ = _tmp39_.bounds;
				_tmp41_ = (*_tmp40_).h;
				_tmp42_.x = (gint16) _tmp26_;
				_tmp42_.y = (gint16) _tmp31_;
				_tmp42_.w = (guint16) ((gint16) _tmp36_);
				_tmp42_.h = (guint16) ((gint16) _tmp41_);
				SDL_UpperBlit (_tmp20_, NULL, _tmp21_, &_tmp42_);
			}
		}
	}
	_tmp43_ = self->surface;
	SDL_Flip (_tmp43_);
}


void game_inputSystem (Game* self, gdouble delta) {
	entitasEntity* _tmp0_ = NULL;
	entitasBounds* _tmp1_ = NULL;
	gdouble _tmp2_ = 0.0;
	entitasEntity* _tmp3_ = NULL;
	entitasBounds* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	entitasEntity* _tmp6_ = NULL;
	entitasBounds* _tmp7_ = NULL;
	gdouble _tmp8_ = 0.0;
	entitasEntity* _tmp9_ = NULL;
	entitasBounds* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gboolean _tmp12_ = FALSE;
	gdouble _tmp15_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->player;
	_tmp1_ = (*_tmp0_).bounds;
	_tmp2_ = self->mouseX;
	_tmp3_ = self->player;
	_tmp4_ = (*_tmp3_).bounds;
	_tmp5_ = (*_tmp4_).w;
	(*_tmp1_).x = (gint) (_tmp2_ - (_tmp5_ / 2));
	_tmp6_ = self->player;
	_tmp7_ = (*_tmp6_).bounds;
	_tmp8_ = self->mouseY;
	_tmp9_ = self->player;
	_tmp10_ = (*_tmp9_).bounds;
	_tmp11_ = (*_tmp10_).h;
	(*_tmp7_).y = (gint) (_tmp8_ - (_tmp11_ / 2));
	_tmp12_ = self->shoot;
	if (_tmp12_) {
		gdouble _tmp13_ = 0.0;
		gdouble _tmp14_ = 0.0;
		_tmp13_ = self->timeToFire;
		_tmp14_ = delta;
		self->timeToFire = _tmp13_ - _tmp14_;
	}
	_tmp15_ = self->timeToFire;
	if (_tmp15_ < 0.0) {
		gdouble _tmp16_ = 0.0;
		_tmp16_ = self->FireRate;
		self->timeToFire = _tmp16_;
	}
}


void game_physicsSystem (Game* self, gdouble delta) {
	g_return_if_fail (self != NULL);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				Factory* _tmp2_ = NULL;
				Factory* _tmp3_ = NULL;
				gint _tmp4_ = 0;
				gboolean _tmp5_ = FALSE;
				Factory* _tmp6_ = NULL;
				gint _tmp7_ = 0;
				gboolean _tmp8_ = FALSE;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = self->factory;
				if (!(i <= (20 - 1))) {
					break;
				}
				_tmp3_ = self->factory;
				_tmp4_ = i;
				_tmp5_ = entitas_entity_isActive (&_tmp3_->pool[_tmp4_]);
				if (!_tmp5_) {
					continue;
				}
				_tmp6_ = self->factory;
				_tmp7_ = i;
				_tmp8_ = entitas_entity_hasVelocity (&_tmp6_->pool[_tmp7_]);
				if (_tmp8_) {
					Factory* _tmp9_ = NULL;
					gint _tmp10_ = 0;
					entitasEntity _tmp11_ = {0};
					entitasPosition* _tmp12_ = NULL;
					Factory* _tmp13_ = NULL;
					gint _tmp14_ = 0;
					entitasEntity _tmp15_ = {0};
					entitasPosition* _tmp16_ = NULL;
					gdouble _tmp17_ = 0.0;
					Factory* _tmp18_ = NULL;
					gint _tmp19_ = 0;
					entitasEntity _tmp20_ = {0};
					entitasVelocity* _tmp21_ = NULL;
					gdouble _tmp22_ = 0.0;
					gdouble _tmp23_ = 0.0;
					Factory* _tmp24_ = NULL;
					gint _tmp25_ = 0;
					entitasEntity _tmp26_ = {0};
					entitasPosition* _tmp27_ = NULL;
					Factory* _tmp28_ = NULL;
					gint _tmp29_ = 0;
					entitasEntity _tmp30_ = {0};
					entitasPosition* _tmp31_ = NULL;
					gdouble _tmp32_ = 0.0;
					Factory* _tmp33_ = NULL;
					gint _tmp34_ = 0;
					entitasEntity _tmp35_ = {0};
					entitasVelocity* _tmp36_ = NULL;
					gdouble _tmp37_ = 0.0;
					gdouble _tmp38_ = 0.0;
					_tmp9_ = self->factory;
					_tmp10_ = i;
					_tmp11_ = _tmp9_->pool[_tmp10_];
					_tmp12_ = _tmp11_.position;
					_tmp13_ = self->factory;
					_tmp14_ = i;
					_tmp15_ = _tmp13_->pool[_tmp14_];
					_tmp16_ = _tmp15_.position;
					_tmp17_ = (*_tmp16_).x;
					_tmp18_ = self->factory;
					_tmp19_ = i;
					_tmp20_ = _tmp18_->pool[_tmp19_];
					_tmp21_ = _tmp20_.velocity;
					_tmp22_ = (*_tmp21_).x;
					_tmp23_ = delta;
					(*_tmp16_).x = _tmp17_ + (_tmp22_ * _tmp23_);
					_tmp24_ = self->factory;
					_tmp25_ = i;
					_tmp26_ = _tmp24_->pool[_tmp25_];
					_tmp27_ = _tmp26_.position;
					_tmp28_ = self->factory;
					_tmp29_ = i;
					_tmp30_ = _tmp28_->pool[_tmp29_];
					_tmp31_ = _tmp30_.position;
					_tmp32_ = (*_tmp31_).y;
					_tmp33_ = self->factory;
					_tmp34_ = i;
					_tmp35_ = _tmp33_->pool[_tmp34_];
					_tmp36_ = _tmp35_.velocity;
					_tmp37_ = (*_tmp36_).y;
					_tmp38_ = delta;
					(*_tmp31_).y = _tmp32_ + (_tmp37_ * _tmp38_);
				}
			}
		}
	}
}


Game* game_new (void) {
	Game* self;
	self = g_slice_new0 (Game);
	game_instance_init (self);
	return self;
}


static void game_instance_init (Game * self) {
	self->sprites = NULL;
	self->FireRate = 0.1;
	self->timeToFire = 0.0;
	self->scale = 1.0;
}


void game_free (Game* self) {
	_factory_free0 (self->factory);
	_g_list_free0 (self->sprites);
	g_slice_free (Game, self);
}



