/* hashmap.c generated by valac 0.34.7, the Vala compiler
 * generated from hashmap.gs, do not modify */


#include <glib.h>
#include <glib-object.h>

typedef struct _HashMap HashMap;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _HashMapEntry HashMapEntry;

struct _HashMap {
	GList* keys;
	GList* data;
};

struct _HashMapEntry {
	gpointer key;
	gpointer value;
};



void hash_map_free (HashMap* self);
static void hash_map_instance_init (HashMap * self);
gboolean hash_map_hasKey (HashMap* self, gconstpointer key);
void hash_map_add (HashMap* self, gconstpointer key, gconstpointer value);
gpointer hash_map_get (HashMap* self, gconstpointer key);
HashMap* hash_map_new (void);
void hash_map_entry_free (HashMapEntry* self);
static void hash_map_entry_instance_init (HashMapEntry * self);
HashMapEntry* hash_map_entry_new (gconstpointer k, gconstpointer v);


gboolean hash_map_hasKey (HashMap* self, gconstpointer key) {
	gboolean result = FALSE;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->keys;
	{
		GList* k_collection = NULL;
		GList* k_it = NULL;
		k_collection = _tmp0_;
		for (k_it = k_collection; k_it != NULL; k_it = k_it->next) {
			gpointer k = NULL;
			k = k_it->data;
			{
				gconstpointer _tmp1_ = NULL;
				gconstpointer _tmp2_ = NULL;
				_tmp1_ = k;
				_tmp2_ = key;
				if (_tmp1_ == _tmp2_) {
					result = TRUE;
					return result;
				}
			}
		}
	}
	result = FALSE;
	return result;
}


void hash_map_add (HashMap* self, gconstpointer key, gconstpointer value) {
	GList* _tmp0_ = NULL;
	gconstpointer _tmp3_ = NULL;
	gconstpointer _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->keys;
	{
		GList* k_collection = NULL;
		GList* k_it = NULL;
		k_collection = _tmp0_;
		for (k_it = k_collection; k_it != NULL; k_it = k_it->next) {
			gpointer k = NULL;
			k = k_it->data;
			{
				gconstpointer _tmp1_ = NULL;
				gconstpointer _tmp2_ = NULL;
				_tmp1_ = k;
				_tmp2_ = key;
				if (_tmp1_ == _tmp2_) {
					return;
				}
			}
		}
	}
	_tmp3_ = key;
	self->keys = g_list_append (self->keys, _tmp3_);
	_tmp4_ = value;
	self->data = g_list_append (self->data, _tmp4_);
}


gpointer hash_map_get (HashMap* self, gconstpointer key) {
	gpointer result = NULL;
	gint index = 0;
	GList* _tmp0_ = NULL;
	GList* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	index = 0;
	_tmp0_ = self->keys;
	{
		GList* k_collection = NULL;
		GList* k_it = NULL;
		k_collection = _tmp0_;
		for (k_it = k_collection; k_it != NULL; k_it = k_it->next) {
			gpointer k = NULL;
			k = k_it->data;
			{
				gconstpointer _tmp1_ = NULL;
				gconstpointer _tmp2_ = NULL;
				gint _tmp3_ = 0;
				_tmp1_ = k;
				_tmp2_ = key;
				if (_tmp1_ == _tmp2_) {
					break;
				}
				_tmp3_ = index;
				index = _tmp3_ + 1;
			}
		}
	}
	_tmp4_ = self->data;
	{
		GList* v_collection = NULL;
		GList* v_it = NULL;
		v_collection = _tmp4_;
		for (v_it = v_collection; v_it != NULL; v_it = v_it->next) {
			gpointer v = NULL;
			v = v_it->data;
			{
				gint _tmp5_ = 0;
				gint _tmp6_ = 0;
				_tmp5_ = index;
				if (_tmp5_ == 0) {
					result = v;
					return result;
				}
				_tmp6_ = index;
				index = _tmp6_ - 1;
			}
		}
	}
	result = NULL;
	return result;
}


HashMap* hash_map_new (void) {
	HashMap* self;
	self = g_slice_new0 (HashMap);
	hash_map_instance_init (self);
	return self;
}


HashMapEntry* hash_map_entry_new (gconstpointer k, gconstpointer v) {
	HashMapEntry* self;
	gconstpointer _tmp0_ = NULL;
	gconstpointer _tmp1_ = NULL;
	self = g_slice_new0 (HashMapEntry);
	hash_map_entry_instance_init (self);
	_tmp0_ = k;
	self->key = _tmp0_;
	_tmp1_ = v;
	self->value = _tmp1_;
	return self;
}


static void hash_map_entry_instance_init (HashMapEntry * self) {
}


void hash_map_entry_free (HashMapEntry* self) {
	g_slice_free (HashMapEntry, self);
}


static void hash_map_instance_init (HashMap * self) {
	self->keys = NULL;
	self->data = NULL;
}


void hash_map_free (HashMap* self) {
	_g_list_free0 (self->keys);
	_g_list_free0 (self->data);
	g_slice_free (HashMap, self);
}



