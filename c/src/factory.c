/* factory.c generated by valac 0.34.7, the Vala compiler
 * generated from factory.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <SDL.h>


#define TYPE_POOL (pool_get_type ())
typedef struct _Factory Factory;

#define ENTITAS_TYPE_ENTITY (entitas_entity_get_type ())

#define ENTITAS_TYPE_BACKGROUND (entitas_background_get_type ())
typedef struct _entitasBackground entitasBackground;

#define ENTITAS_TYPE_BOUNDS (entitas_bounds_get_type ())
typedef struct _entitasBounds entitasBounds;

#define ENTITAS_TYPE_BULLET (entitas_bullet_get_type ())
typedef struct _entitasBullet entitasBullet;

#define ENTITAS_TYPE_ENEMY1 (entitas_enemy1_get_type ())
typedef struct _entitasEnemy1 entitasEnemy1;

#define ENTITAS_TYPE_ENEMY2 (entitas_enemy2_get_type ())
typedef struct _entitasEnemy2 entitasEnemy2;

#define ENTITAS_TYPE_ENEMY3 (entitas_enemy3_get_type ())
typedef struct _entitasEnemy3 entitasEnemy3;

#define ENTITAS_TYPE_EXPIRES (entitas_expires_get_type ())
typedef struct _entitasExpires entitasExpires;

#define ENTITAS_TYPE_HEALTH (entitas_health_get_type ())
typedef struct _entitasHealth entitasHealth;

#define ENTITAS_TYPE_HUD (entitas_hud_get_type ())
typedef struct _entitasHud entitasHud;

#define ENTITAS_TYPE_INDEX (entitas_index_get_type ())
typedef struct _entitasIndex entitasIndex;

#define ENTITAS_TYPE_LAYER (entitas_layer_get_type ())
typedef struct _entitasLayer entitasLayer;

#define ENTITAS_TYPE_POSITION (entitas_position_get_type ())
typedef struct _entitasPosition entitasPosition;

#define ENTITAS_TYPE_SCALE (entitas_scale_get_type ())
typedef struct _entitasScale entitasScale;

#define ENTITAS_TYPE_SPRITE (entitas_sprite_get_type ())
typedef struct _entitasSprite entitasSprite;

#define ENTITAS_TYPE_TEXT (entitas_text_get_type ())
typedef struct _entitasText entitasText;

#define ENTITAS_TYPE_TINT (entitas_tint_get_type ())
typedef struct _entitasTint entitasTint;

#define ENTITAS_TYPE_TWEEN (entitas_tween_get_type ())
typedef struct _entitasTween entitasTween;

#define ENTITAS_TYPE_VELOCITY (entitas_velocity_get_type ())
typedef struct _entitasVelocity entitasVelocity;
typedef struct _entitasEntity entitasEntity;

typedef enum  {
	POOL_BACKGROUND,
	POOL_ENEMY1,
	POOL_ENEMY2,
	POOL_ENEMY3,
	POOL_PLAYER,
	POOL_BULLET,
	POOL_EXPLOSION,
	POOL_BANG,
	POOL_PARTICLE,
	POOL_HUD,
	POOL_Count
} Pool;

struct _entitasBackground {
	gboolean active;
};

struct _entitasBounds {
	gint x;
	gint y;
	gint w;
	gint h;
};

struct _entitasBullet {
	gboolean active;
};

struct _entitasEnemy1 {
	gboolean active;
};

struct _entitasEnemy2 {
	gboolean active;
};

struct _entitasEnemy3 {
	gboolean active;
};

struct _entitasExpires {
	gdouble value;
};

struct _entitasHealth {
	gdouble current;
	gdouble maximum;
};

struct _entitasHud {
	gboolean active;
};

struct _entitasIndex {
	gint value;
};

struct _entitasLayer {
	gint value;
};

struct _entitasPosition {
	gdouble x;
	gdouble y;
};

struct _entitasScale {
	gdouble x;
	gdouble y;
};

struct _entitasSprite {
	SDL_Surface* surface;
};

struct _entitasText {
	gchar* text;
	SDL_Surface* surface;
};

struct _entitasTint {
	gint r;
	gint g;
	gint b;
	gint a;
};

struct _entitasTween {
	gdouble min;
	gdouble max;
	gdouble speed;
	gboolean repeat;
	gboolean active;
};

struct _entitasVelocity {
	gdouble x;
	gdouble y;
};

struct _entitasEntity {
	gint id;
	gchar* name;
	gint pool;
	guint64 mask;
	entitasBackground* background;
	entitasBounds* bounds;
	entitasBullet* bullet;
	entitasEnemy1* enemy1;
	entitasEnemy2* enemy2;
	entitasEnemy3* enemy3;
	entitasExpires* expires;
	entitasHealth* health;
	entitasHud* hud;
	entitasIndex* index;
	entitasLayer* layer;
	entitasPosition* position;
	entitasScale* scale;
	entitasSprite* sprite;
	entitasText* text;
	entitasTint* tint;
	entitasTween* tween;
	entitasVelocity* velocity;
};

struct _Factory {
	entitasEntity pool[20];
	gint id;
	SDL_Surface** cache;
	gint cache_length1;
};



#define TAU (2.0 * G_PI)
GType pool_get_type (void) G_GNUC_CONST;
void factory_free (Factory* self);
GType entitas_entity_get_type (void) G_GNUC_CONST;
GType entitas_background_get_type (void) G_GNUC_CONST;
entitasBackground* entitas_background_dup (const entitasBackground* self);
void entitas_background_free (entitasBackground* self);
GType entitas_bounds_get_type (void) G_GNUC_CONST;
entitasBounds* entitas_bounds_dup (const entitasBounds* self);
void entitas_bounds_free (entitasBounds* self);
GType entitas_bullet_get_type (void) G_GNUC_CONST;
entitasBullet* entitas_bullet_dup (const entitasBullet* self);
void entitas_bullet_free (entitasBullet* self);
GType entitas_enemy1_get_type (void) G_GNUC_CONST;
entitasEnemy1* entitas_enemy1_dup (const entitasEnemy1* self);
void entitas_enemy1_free (entitasEnemy1* self);
GType entitas_enemy2_get_type (void) G_GNUC_CONST;
entitasEnemy2* entitas_enemy2_dup (const entitasEnemy2* self);
void entitas_enemy2_free (entitasEnemy2* self);
GType entitas_enemy3_get_type (void) G_GNUC_CONST;
entitasEnemy3* entitas_enemy3_dup (const entitasEnemy3* self);
void entitas_enemy3_free (entitasEnemy3* self);
GType entitas_expires_get_type (void) G_GNUC_CONST;
entitasExpires* entitas_expires_dup (const entitasExpires* self);
void entitas_expires_free (entitasExpires* self);
GType entitas_health_get_type (void) G_GNUC_CONST;
entitasHealth* entitas_health_dup (const entitasHealth* self);
void entitas_health_free (entitasHealth* self);
GType entitas_hud_get_type (void) G_GNUC_CONST;
entitasHud* entitas_hud_dup (const entitasHud* self);
void entitas_hud_free (entitasHud* self);
GType entitas_index_get_type (void) G_GNUC_CONST;
entitasIndex* entitas_index_dup (const entitasIndex* self);
void entitas_index_free (entitasIndex* self);
GType entitas_layer_get_type (void) G_GNUC_CONST;
entitasLayer* entitas_layer_dup (const entitasLayer* self);
void entitas_layer_free (entitasLayer* self);
GType entitas_position_get_type (void) G_GNUC_CONST;
entitasPosition* entitas_position_dup (const entitasPosition* self);
void entitas_position_free (entitasPosition* self);
GType entitas_scale_get_type (void) G_GNUC_CONST;
entitasScale* entitas_scale_dup (const entitasScale* self);
void entitas_scale_free (entitasScale* self);
GType entitas_sprite_get_type (void) G_GNUC_CONST;
entitasSprite* entitas_sprite_dup (const entitasSprite* self);
void entitas_sprite_free (entitasSprite* self);
GType entitas_text_get_type (void) G_GNUC_CONST;
entitasText* entitas_text_dup (const entitasText* self);
void entitas_text_free (entitasText* self);
void entitas_text_copy (const entitasText* self, entitasText* dest);
void entitas_text_destroy (entitasText* self);
GType entitas_tint_get_type (void) G_GNUC_CONST;
entitasTint* entitas_tint_dup (const entitasTint* self);
void entitas_tint_free (entitasTint* self);
GType entitas_tween_get_type (void) G_GNUC_CONST;
entitasTween* entitas_tween_dup (const entitasTween* self);
void entitas_tween_free (entitasTween* self);
GType entitas_velocity_get_type (void) G_GNUC_CONST;
entitasVelocity* entitas_velocity_dup (const entitasVelocity* self);
void entitas_velocity_free (entitasVelocity* self);
entitasEntity* entitas_entity_dup (const entitasEntity* self);
void entitas_entity_free (entitasEntity* self);
void entitas_entity_copy (const entitasEntity* self, entitasEntity* dest);
void entitas_entity_destroy (entitasEntity* self);
static void factory_instance_init (Factory * self);
entitasEntity* factory_createCore (Factory* self, const gchar* name, gint pool, gboolean active);
entitasEntity* entitas_entity_setId (entitasEntity *self, gint id);
entitasEntity* entitas_entity_setName (entitasEntity *self, const gchar* name);
entitasEntity* entitas_entity_setPool (entitasEntity *self, gint pool);
entitasEntity* entitas_entity_setActive (entitasEntity *self, gboolean active);
entitasEntity* factory_createEntity (Factory* self, const gchar* name, gint pool, SDL_Surface* s, gboolean active);
entitasEntity* entitas_entity_addPosition (entitasEntity *self, gdouble x, gdouble y);
entitasEntity* entitas_entity_addLayer (entitasEntity *self, gint value);
entitasEntity* entitas_entity_addBounds (entitasEntity *self, gint x, gint y, gint w, gint h);
entitasEntity* entitas_entity_addSprite (entitasEntity *self, SDL_Surface* surface);
entitasEntity* factory_createBackground (Factory* self, gint index, gint tile);
entitasEntity* entitas_entity_setBackground (entitasEntity *self, gboolean value);
entitasEntity* factory_createPlayer (Factory* self, gint index);
Factory* factory_new (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GType pool_get_type (void) {
	static volatile gsize pool_type_id__volatile = 0;
	if (g_once_init_enter (&pool_type_id__volatile)) {
		static const GEnumValue values[] = {{POOL_BACKGROUND, "POOL_BACKGROUND", "background"}, {POOL_ENEMY1, "POOL_ENEMY1", "enemy1"}, {POOL_ENEMY2, "POOL_ENEMY2", "enemy2"}, {POOL_ENEMY3, "POOL_ENEMY3", "enemy3"}, {POOL_PLAYER, "POOL_PLAYER", "player"}, {POOL_BULLET, "POOL_BULLET", "bullet"}, {POOL_EXPLOSION, "POOL_EXPLOSION", "explosion"}, {POOL_BANG, "POOL_BANG", "bang"}, {POOL_PARTICLE, "POOL_PARTICLE", "particle"}, {POOL_HUD, "POOL_HUD", "hud"}, {POOL_Count, "POOL_Count", "count"}, {0, NULL, NULL}};
		GType pool_type_id;
		pool_type_id = g_enum_register_static ("Pool", values);
		g_once_init_leave (&pool_type_id__volatile, pool_type_id);
	}
	return pool_type_id__volatile;
}


entitasEntity* factory_createCore (Factory* self, const gchar* name, gint pool, gboolean active) {
	entitasEntity* result = NULL;
	gint id = 0;
	gint _tmp0_ = 0;
	entitasEntity* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	entitasEntity* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	entitasEntity* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	entitasEntity* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = self->id;
	self->id = _tmp0_ + 1;
	id = _tmp0_;
	_tmp1_ = entitas_entity_setId (&self->pool[id], id);
	_tmp2_ = name;
	_tmp3_ = entitas_entity_setName (_tmp1_, _tmp2_);
	_tmp4_ = pool;
	_tmp5_ = entitas_entity_setPool (_tmp3_, _tmp4_);
	_tmp6_ = active;
	_tmp7_ = entitas_entity_setActive (_tmp5_, _tmp6_);
	result = _tmp7_;
	return result;
}


entitasEntity* factory_createEntity (Factory* self, const gchar* name, gint pool, SDL_Surface* s, gboolean active) {
	entitasEntity* result = NULL;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	entitasEntity* _tmp3_ = NULL;
	entitasEntity* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	entitasEntity* _tmp6_ = NULL;
	SDL_Surface* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	SDL_Surface* _tmp9_ = NULL;
	gint _tmp10_ = 0;
	entitasEntity* _tmp11_ = NULL;
	SDL_Surface* _tmp12_ = NULL;
	entitasEntity* _tmp13_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (s != NULL, NULL);
	_tmp0_ = name;
	_tmp1_ = pool;
	_tmp2_ = active;
	_tmp3_ = factory_createCore (self, _tmp0_, _tmp1_, _tmp2_);
	_tmp4_ = entitas_entity_addPosition (_tmp3_, (gdouble) 0, (gdouble) 0);
	_tmp5_ = pool;
	_tmp6_ = entitas_entity_addLayer (_tmp4_, _tmp5_);
	_tmp7_ = s;
	_tmp8_ = _tmp7_->w;
	_tmp9_ = s;
	_tmp10_ = _tmp9_->h;
	_tmp11_ = entitas_entity_addBounds (_tmp6_, 0, 0, _tmp8_, _tmp10_);
	_tmp12_ = s;
	_tmp13_ = entitas_entity_addSprite (_tmp11_, _tmp12_);
	result = _tmp13_;
	return result;
}


entitasEntity* factory_createBackground (Factory* self, gint index, gint tile) {
	entitasEntity* result = NULL;
	entitasEntity* e = NULL;
	SDL_Surface** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	SDL_Surface* _tmp2_ = NULL;
	entitasEntity* _tmp3_ = NULL;
	entitasEntity* _tmp4_ = NULL;
	entitasBounds* _tmp5_ = NULL;
	entitasBounds* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->cache;
	_tmp0__length1 = self->cache_length1;
	_tmp1_ = index;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp3_ = factory_createEntity (self, "background", 0, _tmp2_, TRUE);
	_tmp4_ = entitas_entity_setBackground (_tmp3_, TRUE);
	e = _tmp4_;
	_tmp5_ = (*e).bounds;
	_tmp6_ = (*e).bounds;
	_tmp7_ = (*_tmp6_).w;
	_tmp8_ = tile;
	(*_tmp5_).x = _tmp7_ * _tmp8_;
	result = e;
	return result;
}


entitasEntity* factory_createPlayer (Factory* self, gint index) {
	entitasEntity* result = NULL;
	SDL_Surface** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	SDL_Surface* _tmp2_ = NULL;
	entitasEntity* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->cache;
	_tmp0__length1 = self->cache_length1;
	_tmp1_ = index;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp3_ = factory_createEntity (self, "player", 1, _tmp2_, TRUE);
	result = _tmp3_;
	return result;
}


Factory* factory_new (void) {
	Factory* self;
	self = g_slice_new0 (Factory);
	factory_instance_init (self);
	return self;
}


static void factory_instance_init (Factory * self) {
	SDL_Surface* _tmp0_ = NULL;
	SDL_Surface* _tmp1_ = NULL;
	SDL_Surface* _tmp2_ = NULL;
	SDL_Surface* _tmp3_ = NULL;
	SDL_Surface* _tmp4_ = NULL;
	SDL_Surface* _tmp5_ = NULL;
	SDL_Surface* _tmp6_ = NULL;
	SDL_Surface* _tmp7_ = NULL;
	SDL_Surface* _tmp8_ = NULL;
	SDL_Surface** _tmp9_ = NULL;
	self->id = 0;
	_tmp0_ = SDL_LoadBMP ("assets/images/background.png");
	_tmp1_ = SDL_LoadBMP ("assets/images/enemy1.png");
	_tmp2_ = SDL_LoadBMP ("assets/images/enemy2.png");
	_tmp3_ = SDL_LoadBMP ("assets/images/enemy3.png");
	_tmp4_ = SDL_LoadBMP ("assets/images/spaceshipspr.png");
	_tmp5_ = SDL_LoadBMP ("assets/images/bullet.png");
	_tmp6_ = SDL_LoadBMP ("assets/images/explosion.png");
	_tmp7_ = SDL_LoadBMP ("assets/images/explosion.png");
	_tmp8_ = SDL_LoadBMP ("assets/images/particle.png");
	_tmp9_ = g_new0 (SDL_Surface*, 9 + 1);
	_tmp9_[0] = _tmp0_;
	_tmp9_[1] = _tmp1_;
	_tmp9_[2] = _tmp2_;
	_tmp9_[3] = _tmp3_;
	_tmp9_[4] = _tmp4_;
	_tmp9_[5] = _tmp5_;
	_tmp9_[6] = _tmp6_;
	_tmp9_[7] = _tmp7_;
	_tmp9_[8] = _tmp8_;
	self->cache = _tmp9_;
	self->cache_length1 = 9;
}


void factory_free (Factory* self) {
	_vala_array_destroy (self->pool, 20, (GDestroyNotify) entitas_entity_destroy);
	self->cache = (_vala_array_free (self->cache, self->cache_length1, (GDestroyNotify) SDL_FreeSurface), NULL);
	g_slice_free (Factory, self);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



