/* File.c generated by valac 0.34.8, the Vala compiler
 * generated from File.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include "sys/stat.h"
#include "stdio.h"
#include "dirent.h"


#define UTIL_TYPE_FILE (util_file_get_type ())
#define UTIL_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UTIL_TYPE_FILE, utilFile))
#define UTIL_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UTIL_TYPE_FILE, utilFileClass))
#define UTIL_IS_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UTIL_TYPE_FILE))
#define UTIL_IS_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UTIL_TYPE_FILE))
#define UTIL_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UTIL_TYPE_FILE, utilFileClass))

typedef struct _utilFile utilFile;
typedef struct _utilFileClass utilFileClass;
typedef struct _utilFilePrivate utilFilePrivate;

#define UTIL_TYPE_STRING (util_string_get_type ())
#define UTIL_STRING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UTIL_TYPE_STRING, utilString))
#define UTIL_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UTIL_TYPE_STRING, utilStringClass))
#define UTIL_IS_STRING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UTIL_TYPE_STRING))
#define UTIL_IS_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UTIL_TYPE_STRING))
#define UTIL_STRING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UTIL_TYPE_STRING, utilStringClass))

typedef struct _utilString utilString;
typedef struct _utilStringClass utilStringClass;
#define _g_free0(var) ((var == NULL) ? NULL : (var = (g_free (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _closedir0(var) ((var == NULL) ? NULL : (var = (closedir (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _utilFile {
	GObject parent_instance;
	utilFilePrivate * priv;
	guint8* buf;
	gint buf_length1;
	struct stat* stat;
	gchar* path;
	gchar** files;
	gint files_length1;
	gchar* ioBuff;
	gint ioBuff_length1;
	GList* fileList;
};

struct _utilFileClass {
	GObjectClass parent_class;
};


static gpointer util_file_parent_class = NULL;

#define UTIL_pathSeparator "/"
#define UTIL_pathSeparatorChar '/'
GType util_file_get_type (void) G_GNUC_CONST;
GType util_string_get_type (void) G_GNUC_CONST;
enum  {
	UTIL_FILE_DUMMY_PROPERTY
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
utilFile* util_file_new (const gchar* path);
utilFile* util_file_construct (GType object_type, const gchar* path);
gchar* util_file_getPath (utilFile* self);
gchar* util_file_getName (utilFile* self);
gchar* util_file_getParent (utilFile* self);
gboolean util_file_exists (utilFile* self);
static struct stat* _stat_dup (struct stat* self);
gboolean util_file_isFile (utilFile* self);
gboolean util_file_isDirectory (utilFile* self);
gint util_file_length (utilFile* self);
gchar* util_file_read (utilFile* self);
gchar** util_file_list (utilFile* self, int* result_length1);
static gchar** _vala_array_dup2 (gchar** self, int length);
utilString* util_string_new (const gchar* str);
utilString* util_string_construct (GType object_type, const gchar* str);
gchar* util_string_to_string (utilString* self);
static gchar** _vala_array_dup3 (gchar** self, int length);
static void util_file_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


utilFile* util_file_construct (GType object_type, const gchar* path) {
	utilFile * self = NULL;
	const gchar* _tmp0_ = NULL;
	guint8* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	gchar* _tmp2_ = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	self = (utilFile*) g_object_new (object_type, NULL);
	_tmp0_ = path;
	_tmp1_ = self->buf;
	_tmp1__length1 = self->buf_length1;
	_tmp2_ = realpath (_tmp0_, _tmp1_);
	_g_free0 (self->path);
	self->path = (gchar*) _tmp2_;
	return self;
}


utilFile* util_file_new (const gchar* path) {
	return util_file_construct (UTIL_TYPE_FILE, path);
}


gchar* util_file_getPath (utilFile* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->path;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


/**
 * the name is everything after the final separator
 */
static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_ = 0L;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


gchar* util_file_getName (utilFile* self) {
	gchar* result = NULL;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gint i = 0;
		const gchar* _tmp0_ = NULL;
		gint _tmp1_ = 0;
		gint _tmp2_ = 0;
		_tmp0_ = self->path;
		_tmp1_ = strlen (_tmp0_);
		_tmp2_ = _tmp1_;
		i = _tmp2_ - 1;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				const gchar* _tmp6_ = NULL;
				gint _tmp7_ = 0;
				gchar _tmp8_ = '\0';
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ - 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				if (!(_tmp5_ > 0)) {
					break;
				}
				_tmp6_ = self->path;
				_tmp7_ = i;
				_tmp8_ = string_get (_tmp6_, (glong) _tmp7_);
				if (_tmp8_ == UTIL_pathSeparatorChar) {
					const gchar* _tmp9_ = NULL;
					gint _tmp10_ = 0;
					gchar* _tmp11_ = NULL;
					_tmp9_ = self->path;
					_tmp10_ = i;
					_tmp11_ = string_substring (_tmp9_, (glong) (_tmp10_ + 1), (glong) -1);
					result = _tmp11_;
					return result;
				}
			}
		}
	}
	_tmp12_ = self->path;
	_tmp13_ = g_strdup (_tmp12_);
	result = _tmp13_;
	return result;
}


/**
 * the parent is everything prior to the final separator
 */
gchar* util_file_getParent (utilFile* self) {
	gchar* result = NULL;
	gchar* _tmp12_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		gint i = 0;
		const gchar* _tmp0_ = NULL;
		gint _tmp1_ = 0;
		gint _tmp2_ = 0;
		_tmp0_ = self->path;
		_tmp1_ = strlen (_tmp0_);
		_tmp2_ = _tmp1_;
		i = _tmp2_ - 1;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_ = 0;
				const gchar* _tmp6_ = NULL;
				gint _tmp7_ = 0;
				gchar _tmp8_ = '\0';
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ - 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				if (!(_tmp5_ > 0)) {
					break;
				}
				_tmp6_ = self->path;
				_tmp7_ = i;
				_tmp8_ = string_get (_tmp6_, (glong) _tmp7_);
				if (_tmp8_ == UTIL_pathSeparatorChar) {
					const gchar* _tmp9_ = NULL;
					gint _tmp10_ = 0;
					gchar* _tmp11_ = NULL;
					_tmp9_ = self->path;
					_tmp10_ = i;
					_tmp11_ = string_substring (_tmp9_, (glong) 0, (glong) (_tmp10_ - 1));
					result = _tmp11_;
					return result;
				}
			}
		}
	}
	_tmp12_ = g_strdup ("");
	result = _tmp12_;
	return result;
}


/**
 * check if the represented struture exists on the virtual disk
 */
static struct stat* _stat_dup (struct stat* self) {
	struct stat* dup;
	dup = g_new0 (struct stat, 1);
	memcpy (dup, self, sizeof (struct stat));
	return dup;
}


static gpointer __stat_dup0 (gpointer self) {
	return self ? _stat_dup (self) : NULL;
}


gboolean util_file_exists (utilFile* self) {
	gboolean result = FALSE;
	const gchar* _tmp0_ = NULL;
	struct stat _tmp1_ = {0};
	gint _tmp2_ = 0;
	struct stat _tmp3_ = {0};
	struct stat* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->path;
	_tmp2_ = stat (_tmp0_, &_tmp1_);
	_g_free0 (self->stat);
	_tmp3_ = _tmp1_;
	_tmp4_ = __stat_dup0 (&_tmp3_);
	self->stat = _tmp4_;
	result = _tmp2_ == 0;
	return result;
}


/**
 * is it a file?
 */
gboolean util_file_isFile (utilFile* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = util_file_exists (self);
	if (_tmp1_) {
		struct stat* _tmp2_ = NULL;
		mode_t _tmp3_ = {0};
		gboolean _tmp4_ = FALSE;
		_tmp2_ = self->stat;
		_tmp3_ = (*_tmp2_).st_mode;
		_tmp4_ = S_ISREG (_tmp3_);
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


/**
 * is it a folder?
 */
gboolean util_file_isDirectory (utilFile* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = util_file_exists (self);
	if (_tmp1_) {
		struct stat* _tmp2_ = NULL;
		mode_t _tmp3_ = {0};
		gboolean _tmp4_ = FALSE;
		_tmp2_ = self->stat;
		_tmp3_ = (*_tmp2_).st_mode;
		_tmp4_ = S_ISDIR (_tmp3_);
		_tmp0_ = _tmp4_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


gint util_file_length (utilFile* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (self != NULL, 0);
	_tmp1_ = util_file_exists (self);
	if (_tmp1_) {
		struct stat* _tmp2_ = NULL;
		gsize _tmp3_ = 0UL;
		_tmp2_ = self->stat;
		_tmp3_ = (*_tmp2_).st_size;
		_tmp0_ = (gint) _tmp3_;
	} else {
		_tmp0_ = 0;
	}
	result = _tmp0_;
	return result;
}


gchar* util_file_read (utilFile* self) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint l = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	gint _tmp6_ = 0;
	gchar _tmp7_ = '\0';
	FILE* f = NULL;
	const gchar* _tmp8_ = NULL;
	FILE* _tmp9_ = NULL;
	FILE* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gint _tmp11__length1 = 0;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = util_file_isFile (self);
	if (!_tmp0_) {
		gchar* _tmp1_ = NULL;
		_tmp1_ = g_strdup ("");
		result = _tmp1_;
		return result;
	}
	_tmp2_ = util_file_length (self);
	l = _tmp2_;
	_tmp3_ = l;
	_tmp4_ = g_new0 (gchar, _tmp3_ + 1);
	self->ioBuff = (g_free (self->ioBuff), NULL);
	self->ioBuff = _tmp4_;
	self->ioBuff_length1 = _tmp3_ + 1;
	_tmp5_ = self->ioBuff;
	_tmp5__length1 = self->ioBuff_length1;
	_tmp6_ = l;
	_tmp5_[_tmp6_] = (gchar) 0;
	_tmp7_ = _tmp5_[_tmp6_];
	_tmp8_ = self->path;
	_tmp9_ = fopen (_tmp8_, "r");
	f = _tmp9_;
	_tmp10_ = f;
	_tmp11_ = self->ioBuff;
	_tmp11__length1 = self->ioBuff_length1;
	_tmp12_ = fgets (_tmp11_, _tmp11__length1, _tmp10_);
	_tmp13_ = g_strdup (_tmp12_);
	result = _tmp13_;
	_fclose0 (f);
	return result;
}


/**
 * return the list of files in the folder
 */
static gchar** _vala_array_dup2 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gchar** _vala_array_dup3 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


gchar** util_file_list (utilFile* self, int* result_length1) {
	gchar** result = NULL;
	gboolean _tmp0_ = FALSE;
	DIR* dp = NULL;
	struct dirent* ep = NULL;
	const gchar* _tmp5_ = NULL;
	DIR* _tmp6_ = NULL;
	DIR* _tmp7_ = NULL;
	GList* _tmp15_ = NULL;
	guint _tmp16_ = 0U;
	gchar** _tmp17_ = NULL;
	gint i = 0;
	GList* _tmp18_ = NULL;
	gchar** _tmp25_ = NULL;
	gint _tmp25__length1 = 0;
	gchar** _tmp26_ = NULL;
	gint _tmp26__length1 = 0;
	gchar** _tmp27_ = NULL;
	gint _tmp27__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = util_file_isDirectory (self);
	if (!_tmp0_) {
		gchar** _tmp1_ = NULL;
		gchar** _tmp2_ = NULL;
		gint _tmp2__length1 = 0;
		gchar** _tmp3_ = NULL;
		gint _tmp3__length1 = 0;
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		_tmp1_ = g_new0 (gchar*, 0 + 1);
		self->files = (_vala_array_free (self->files, self->files_length1, (GDestroyNotify) g_free), NULL);
		self->files = _tmp1_;
		self->files_length1 = 0;
		_tmp2_ = self->files;
		_tmp2__length1 = self->files_length1;
		_tmp3_ = (_tmp2_ != NULL) ? _vala_array_dup2 (_tmp2_, _tmp2__length1) : ((gpointer) _tmp2_);
		_tmp3__length1 = _tmp2__length1;
		_tmp4_ = _tmp3_;
		_tmp4__length1 = _tmp3__length1;
		if (result_length1) {
			*result_length1 = _tmp4__length1;
		}
		result = _tmp4_;
		return result;
	}
	__g_list_free__g_object_unref0_0 (self->fileList);
	self->fileList = NULL;
	_tmp5_ = self->path;
	_tmp6_ = opendir (_tmp5_);
	_closedir0 (dp);
	dp = _tmp6_;
	_tmp7_ = dp;
	if (_tmp7_ != NULL) {
		while (TRUE) {
			DIR* _tmp8_ = NULL;
			struct dirent* _tmp9_ = NULL;
			struct dirent* _tmp10_ = NULL;
			utilString* s = NULL;
			struct dirent* _tmp11_ = NULL;
			utilString* _tmp12_ = NULL;
			utilString* _tmp13_ = NULL;
			utilString* _tmp14_ = NULL;
			_tmp8_ = dp;
			_tmp9_ = readdir (_tmp8_);
			ep = _tmp9_;
			_tmp10_ = ep;
			if (!(_tmp10_ != NULL)) {
				break;
			}
			_tmp11_ = ep;
			_tmp12_ = util_string_new ((const gchar*) _tmp11_->d_name);
			s = _tmp12_;
			_tmp13_ = s;
			_tmp14_ = _g_object_ref0 (_tmp13_);
			self->fileList = g_list_append (self->fileList, _tmp14_);
			_g_object_unref0 (s);
		}
	}
	_tmp15_ = self->fileList;
	_tmp16_ = g_list_length (_tmp15_);
	_tmp17_ = g_new0 (gchar*, _tmp16_ + 1);
	self->files = (_vala_array_free (self->files, self->files_length1, (GDestroyNotify) g_free), NULL);
	self->files = _tmp17_;
	self->files_length1 = _tmp16_;
	i = 0;
	_tmp18_ = self->fileList;
	{
		GList* s_collection = NULL;
		GList* s_it = NULL;
		s_collection = _tmp18_;
		for (s_it = s_collection; s_it != NULL; s_it = s_it->next) {
			utilString* _tmp19_ = NULL;
			utilString* s = NULL;
			_tmp19_ = _g_object_ref0 ((utilString*) s_it->data);
			s = _tmp19_;
			{
				gchar** _tmp20_ = NULL;
				gint _tmp20__length1 = 0;
				gint _tmp21_ = 0;
				utilString* _tmp22_ = NULL;
				gchar* _tmp23_ = NULL;
				gchar* _tmp24_ = NULL;
				_tmp20_ = self->files;
				_tmp20__length1 = self->files_length1;
				_tmp21_ = i;
				i = _tmp21_ + 1;
				_tmp22_ = s;
				_tmp23_ = util_string_to_string (_tmp22_);
				_g_free0 (_tmp20_[_tmp21_]);
				_tmp20_[_tmp21_] = _tmp23_;
				_tmp24_ = _tmp20_[_tmp21_];
				_g_object_unref0 (s);
			}
		}
	}
	_tmp25_ = self->files;
	_tmp25__length1 = self->files_length1;
	_tmp26_ = (_tmp25_ != NULL) ? _vala_array_dup3 (_tmp25_, _tmp25__length1) : ((gpointer) _tmp25_);
	_tmp26__length1 = _tmp25__length1;
	_tmp27_ = _tmp26_;
	_tmp27__length1 = _tmp26__length1;
	if (result_length1) {
		*result_length1 = _tmp27__length1;
	}
	result = _tmp27_;
	_closedir0 (dp);
	return result;
}


static void util_file_class_init (utilFileClass * klass) {
	util_file_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = util_file_finalize;
}


static void util_file_instance_init (utilFile * self) {
	guint8* _tmp0_ = NULL;
	_tmp0_ = g_new0 (guint8, 4096);
	self->buf = _tmp0_;
	self->buf_length1 = 4096;
}


static void util_file_finalize (GObject* obj) {
	utilFile * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UTIL_TYPE_FILE, utilFile);
	self->buf = (g_free (self->buf), NULL);
	_g_free0 (self->stat);
	_g_free0 (self->path);
	self->files = (_vala_array_free (self->files, self->files_length1, (GDestroyNotify) g_free), NULL);
	self->ioBuff = (g_free (self->ioBuff), NULL);
	__g_list_free__g_object_unref0_0 (self->fileList);
	G_OBJECT_CLASS (util_file_parent_class)->finalize (obj);
}


/**
 * Simple File handler
 * 
 */
GType util_file_get_type (void) {
	static volatile gsize util_file_type_id__volatile = 0;
	if (g_once_init_enter (&util_file_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (utilFileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) util_file_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (utilFile), 0, (GInstanceInitFunc) util_file_instance_init, NULL };
		GType util_file_type_id;
		util_file_type_id = g_type_register_static (G_TYPE_OBJECT, "utilFile", &g_define_type_info, 0);
		g_once_init_leave (&util_file_type_id__volatile, util_file_type_id);
	}
	return util_file_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



