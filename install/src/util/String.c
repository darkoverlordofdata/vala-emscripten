/* String.c generated by valac 0.34.8, the Vala compiler
 * generated from String.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define UTIL_TYPE_STRING (util_string_get_type ())
#define UTIL_STRING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), UTIL_TYPE_STRING, utilString))
#define UTIL_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), UTIL_TYPE_STRING, utilStringClass))
#define UTIL_IS_STRING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), UTIL_TYPE_STRING))
#define UTIL_IS_STRING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), UTIL_TYPE_STRING))
#define UTIL_STRING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), UTIL_TYPE_STRING, utilStringClass))

typedef struct _utilString utilString;
typedef struct _utilStringClass utilStringClass;
typedef struct _utilStringPrivate utilStringPrivate;

struct _utilString {
	GObject parent_instance;
	utilStringPrivate * priv;
	gchar* buf;
	gint buf_length1;
};

struct _utilStringClass {
	GObjectClass parent_class;
};


static gpointer util_string_parent_class = NULL;

GType util_string_get_type (void) G_GNUC_CONST;
enum  {
	UTIL_STRING_DUMMY_PROPERTY
};
utilString* util_string_new (const gchar* str);
utilString* util_string_construct (GType object_type, const gchar* str);
gchar* util_string_to_string (utilString* self);
static void util_string_finalize (GObject* obj);


static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_ = 0L;
	gchar _tmp1_ = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


utilString* util_string_construct (GType object_type, const gchar* str) {
	utilString * self = NULL;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (str != NULL, NULL);
	self = (utilString*) g_object_new (object_type, NULL);
	_tmp0_ = str;
	_tmp1_ = strlen (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_new0 (gchar, _tmp2_);
	self->buf = (g_free (self->buf), NULL);
	self->buf = _tmp3_;
	self->buf_length1 = _tmp2_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				gint _tmp6_ = 0;
				const gchar* _tmp7_ = NULL;
				gint _tmp8_ = 0;
				gint _tmp9_ = 0;
				gchar* _tmp10_ = NULL;
				gint _tmp10__length1 = 0;
				gint _tmp11_ = 0;
				const gchar* _tmp12_ = NULL;
				gint _tmp13_ = 0;
				gchar _tmp14_ = '\0';
				gchar _tmp15_ = '\0';
				if (!_tmp4_) {
					gint _tmp5_ = 0;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp4_ = FALSE;
				_tmp6_ = i;
				_tmp7_ = str;
				_tmp8_ = strlen (_tmp7_);
				_tmp9_ = _tmp8_;
				if (!(_tmp6_ < _tmp9_)) {
					break;
				}
				_tmp10_ = self->buf;
				_tmp10__length1 = self->buf_length1;
				_tmp11_ = i;
				_tmp12_ = str;
				_tmp13_ = i;
				_tmp14_ = string_get (_tmp12_, (glong) _tmp13_);
				_tmp10_[_tmp11_] = _tmp14_;
				_tmp15_ = _tmp10_[_tmp11_];
			}
		}
	}
	return self;
}


utilString* util_string_new (const gchar* str) {
	return util_string_construct (UTIL_TYPE_STRING, str);
}


gchar* util_string_to_string (utilString* self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->buf;
	_tmp0__length1 = self->buf_length1;
	_tmp1_ = g_strdup ((const gchar*) _tmp0_);
	result = _tmp1_;
	return result;
}


static void util_string_class_init (utilStringClass * klass) {
	util_string_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = util_string_finalize;
}


static void util_string_instance_init (utilString * self) {
}


static void util_string_finalize (GObject* obj) {
	utilString * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, UTIL_TYPE_STRING, utilString);
	self->buf = (g_free (self->buf), NULL);
	G_OBJECT_CLASS (util_string_parent_class)->finalize (obj);
}


/**
 * Not a replacement for string type
     *
     * String holds on to a char buffer for strings
     * returned from Posix calls so that their memory
     * will not be reclaimed.
     * @see utils.File 
 * 
 */
GType util_string_get_type (void) {
	static volatile gsize util_string_type_id__volatile = 0;
	if (g_once_init_enter (&util_string_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (utilStringClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) util_string_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (utilString), 0, (GInstanceInitFunc) util_string_instance_init, NULL };
		GType util_string_type_id;
		util_string_type_id = g_type_register_static (G_TYPE_OBJECT, "utilString", &g_define_type_info, 0);
		g_once_init_leave (&util_string_type_id__volatile, util_string_type_id);
	}
	return util_string_type_id__volatile;
}



